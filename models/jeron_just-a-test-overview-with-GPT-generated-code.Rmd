---
title: "R Notebook"
output: html_notebook
---

```{r}
# install.packages(c("readxl","dplyr")) 
```


```{r}
library(readxl)
library(dplyr)
library(tidyr)
library(ggplot2)
library(ranger)
```


```{r}

df <- read_excel("../data/goyal_predictors.xlsx", sheet = "Monthly")

keep_predictors <- c(
  "yyyymm",
  "ret", "Rfree",
  "price","d12","e12",
  "BAA","lty","d/p","d/y","e/p","d/e",
  "tms","dfy","dfr","svar","infl",
  "AAA","tbl","b/m","ltr","corpr","lzrt",
  "ogap","wtexas","dtoy","dtoat","avgcor",
  "fbm","skvw","tail","rdsp","ntis"
)

keep_predictors_clean <- make.names(keep_predictors)


#filter for date 1950 01 to 2024 11
df <- df %>%
  mutate(.yyyymm_num = as.integer(gsub("[^0-9]", "", as.character(yyyymm)))) %>%
  filter(!is.na(.yyyymm_num), between(.yyyymm_num, 195001L, 202411L)) %>%
  select(-.yyyymm_num)  %>%
  select(any_of(keep_predictors_clean))# keep all original columns

df <- df %>% select(any_of(keep_predictors_clean))


# schema-style overview
#df %>% glimpse()
# dplyr-based "head"
df %>% slice_head(n = 10)
df
```


```{r}
# check for NAs or zeros

# NA checks on df
anyNA(df)                  # any NA?
sum(is.na(df))             # total NA count
colSums(is.na(df))         # NA count per column

# Row indices with any NA
rows_with_na <- which(!complete.cases(df))
rows_with_na

```

```{r}
# create columns

df <- df %>%
  mutate(
    erp = as.numeric(ret) - as.numeric(Rfree)  # equity return minus risk-free
  )

df
```

```{r, fig.width=14, fig.height=15, out.width="100%"}
#visualise erp

df_long <- df %>%
  mutate(date = as.Date(paste0(yyyymm, "01"), "%Y%m%d")) %>%
  transmute(date,
            ret  = as.numeric(ret)  * 100,
            Rfree= as.numeric(Rfree)* 100,
            erp  = as.numeric(erp)  * 100) %>%
  tidyr::pivot_longer(c(ret, Rfree, erp), names_to = "series", values_to = "value") %>%
  arrange(series, date) %>%
  group_by(series) %>%
  mutate(roll12 = zoo::rollmean(value, 12, fill = NA, align = "right")) %>%
  ungroup()

ggplot(df_long, aes(date, value)) +
  geom_line(alpha = 0.35) +
  geom_line(aes(y = roll12), linewidth = 0.6) +
  facet_wrap(~series, ncol = 1, scales = "free_y") +
  labs(x = "Date", y = "Percent", title = "ret, Rfree, and erp (scaled ×100)",
       subtitle = "Faint = monthly; bold = 12-month rolling mean") +
  theme_minimal() +
  theme(legend.position = "none",
        strip.text = element_text(face = "bold"),
        panel.spacing.y = unit(6, "pt"))
```

```{r, fig.width=14, fig.height=10, out.width="100%"}

# 1) Geometric annual returns and ERP
df_annual <- df %>%
  mutate(date = as.Date(paste0(yyyymm, "01"), "%Y%m%d"),
         year = as.integer(format(date, "%Y")),
         ret   = as.numeric(ret),
         Rfree = as.numeric(Rfree)) %>%
  group_by(year) %>%
  summarise(
    ret   = prod(1 + ret,   na.rm = TRUE) - 1,
    Rfree = prod(1 + Rfree, na.rm = TRUE) - 1,
    .groups = "drop"
  ) %>%
  mutate(
    erp  = (1 + ret) / (1 + Rfree) - 1,
    date = as.Date(paste0(year, "-01-01"))
  )


df_annual

# 2) Long format, scaled ×100 (no rolling average)
df_annual_long <- df_annual %>%
  transmute(date,
            ret   = ret   * 100,
            Rfree = Rfree * 100,
            erp   = erp   * 100) %>%
  tidyr::pivot_longer(c(ret, Rfree, erp), names_to = "series", values_to = "value") %>%
  arrange(series, date)

# 3) Plot actual values in black
ggplot(df_annual_long, aes(date, value)) +
  geom_line(color = "black") +
  geom_point(color = "black", size = 0.6) +
  facet_wrap(~series, ncol = 1, scales = "free_y") +
  labs(x = "Year", y = "Percent",
       title = "Annual ret, Rfree, and erp (geometric, ×100)") +
  theme_minimal() +
  theme(legend.position = "none",
        strip.text = element_text(face = "bold"),
        panel.spacing.y = unit(6, "pt"))
```

```{r}
mean_full <- mean(df$erp, na.rm = TRUE)
var_full  <- var(df$erp,  na.rm = TRUE)
sd_full   <- sd(df$erp,   na.rm = TRUE)
min_full  <- min(df$erp,  na.rm = TRUE)
max_full  <- max(df$erp,  na.rm = TRUE)

c(mean_full, var_full, sd_full, min_full, max_full)*100
```



```{r}
# feature engineering

df <- df %>%
  arrange(as.Date(paste0(yyyymm, "01"), "%Y%m%d")) %>%
  mutate(across(
    everything(),                          # use where(is.numeric) if you want numeric-only
    list(L1 = ~ dplyr::lag(.x, 1),
         L2 = ~ dplyr::lag(.x, 2),
         L3 = ~ dplyr::lag(.x, 3)),
    .names = "{.col}_{.fn}"
  ))
```


```{r}
# 0) Prep monthly data
df_ts <- df %>%
  mutate(
    date   = as.Date(paste0(yyyymm, "01"), "%Y%m%d"),
    erp    = as.numeric(erp)
  ) %>%
  arrange(date)

df_ts
```

```{r}
# prevailing mean model

df_ts <- df %>%
  mutate(date = as.Date(paste0(yyyymm, "01"), "%Y%m%d"),
         erp  = as.numeric(erp)) %>%
  arrange(date)

# 1) Target ERP at t+1
data_mod <- df_ts %>% mutate(erp_t1 = dplyr::lead(erp, 1))

# 2) Keep rows with complete target
data_clean <- data_mod %>%
  select(date, erp_t1) %>%
  drop_na(erp_t1) %>%
  arrange(date)

# 3) 80/20 time split
n <- nrow(data_clean)
split <- floor(0.8 * n)
train <- data_clean[1:split, ]
test  <- data_clean[(split + 1):n, ]

# 4) Prevailing-mean predictor (constant = mean of training target)
mu_train <- mean(train$erp_t1)
pred <- rep(mu_train, nrow(test))

# 5) Results and metrics
results_mean <- tibble(
  date_t1 = test$date,
  y_true  = test$erp_t1,
  y_pred  = pred
)

mae_mean  <- mean(abs(results_mean$y_pred - results_mean$y_true))
rmse_mean <- sqrt(mean((results_mean$y_pred - results_mean$y_true)^2))

list(
  n_train = nrow(train),
  n_test  = nrow(test),
  train_mean = mu_train,
  MAE = mae_mean,
  RMSE = rmse_mean,
  last_10 = tail(results_mean, 10)
)
```


```{r}
# RF model
# 1) Build target ERP at t+1
data_mod <- df_ts %>%
  mutate(erp_t1 = dplyr::lead(erp, 1))

# 2) Keep numeric predictors only, drop target leakage columns
num_cols <- data_mod %>%
  select(where(is.numeric)) %>%
  names()

drop_cols <- c("erp_t1")             # target
# Keep all numeric predictors including current-period erp and others, exclude the target
predictor_cols <- setdiff(num_cols, drop_cols)

# 3) Remove rows with missing target or predictors
data_clean <- data_mod %>%
  select(all_of(c("erp_t1", predictor_cols)), date) %>%
  tidyr::drop_na(erp_t1) %>%
  tidyr::drop_na(all_of(predictor_cols)) %>%
  arrange(date)

# 4) Walk-forward training: train on 1..t, predict t+1
min_train <- 150L  # at least 60 months to start; adjust as needed
n <- nrow(data_clean)

stopifnot(n > (min_train + 1))

preds <- rep(NA_real_, n)
truth <- rep(NA_real_, n)
dates <- data_clean$date

for (i in seq.int(min_train, n - 1L)) {
  train_idx <- 1:i
  test_idx  <- i + 1L

  fit <- ranger(
    formula = erp_t1 ~ .,
    data    = data_clean[train_idx, c("erp_t1", predictor_cols)],
    num.trees = 500,
    mtry       = floor(sqrt(length(predictor_cols))),
    min.node.size = 5,
    seed = 42
  )

  preds[test_idx] <- predict(fit, data = data_clean[test_idx, predictor_cols])$predictions
  truth[test_idx] <- data_clean$erp_t1[test_idx]
}

# 5) Collect results and simple accuracy
results <- tibble(
  date_t1 = dates,         # prediction is for t+1 aligned by date row
  y_true  = truth,
  y_pred  = preds
) %>%
  filter(!is.na(y_true), !is.na(y_pred))

mae  <- mean(abs(results$y_pred - results$y_true))
rmse <- sqrt(mean((results$y_pred - results$y_true)^2))

list(
  n_obs_used   = nrow(results),
  MAE          = mae,
  RMSE         = rmse,
  head_results = tail(results, 10)
)
```


```{r}


# 0) Prepare monthly data
df_ts <- df %>%
  mutate(date = as.Date(paste0(yyyymm, "01"), "%Y%m%d"),
         erp  = as.numeric(erp)) %>%
  arrange(date)

# 1) Target ERP at t+1
data_mod <- df_ts %>%
  mutate(erp_t1 = dplyr::lead(erp, 1))

# 2) Keep numeric predictors only, exclude target
num_cols <- names(select(data_mod, where(is.numeric)))
predictor_cols <- setdiff(num_cols, "erp_t1")

# 3) Clean rows
data_clean <- data_mod %>%
  select(date, erp_t1, all_of(predictor_cols)) %>%
  drop_na(erp_t1, all_of(predictor_cols)) %>%
  arrange(date)

# 4) 80/20 split by time
n <- nrow(data_clean)
split <- floor(0.8 * n)
train <- data_clean[1:split, ]
test  <- data_clean[(split + 1):n, ]

# 5) Fit once on train, predict test
rf_formula <- reformulate(predictor_cols, response = "erp_t1")
fit <- ranger(
  rf_formula, data = train,
  num.trees = 500,
  mtry = floor(sqrt(length(predictor_cols))),
  min.node.size = 5,
  seed = 42
)

pred <- predict(fit, data = test[, predictor_cols])$predictions

# 6) Results and metrics
results <- tibble(
  date_t1 = test$date,  # features at t, target is ERP at t+1
  y_true  = test$erp_t1,
  y_pred  = pred
)

mae  <- mean(abs(results$y_pred - results$y_true))
rmse <- sqrt(mean((results$y_pred - results$y_true)^2))

list(
  n_train = nrow(train),
  n_test  = nrow(results),
  MAE = mae,
  RMSE = rmse,
  last_10 = tail(results, 10)
)
```











Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Cmd+Option+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Cmd+Shift+K* to preview the HTML file). 

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.

