# This code calculates and plots the grouped SHAP feature contributions of the XGBoost model 
# over the forecast window for different horizons (h=1, 3, 6, 12).
# It accumulates the SHAP values for each group over multiple rolling windows, 
# calculates the average absolute SHAP values per feature, and then visualizes the results.
# Specify the desired forecast horizon h.

```{r}
# Load required libraries
library(ggplot2)
library(dplyr)
library(xgboost)
library(tidyr)
```
```{r}
# set value of h
h = 1

df = read.csv("../data/full_df.csv") %>% mutate(date = as.Date(date, format = "%m/%d/%y")) 
date_col <- tail(df$date, WINDOW_SIZE) 
```

```{r}

```

```{r}
# ----- 4-bucket mapper -----
assign_group_4way <- function(v) {
  v0 <- str_remove(v, "_lag\\d+$")              # strip trailing _lagk
  v0 <- str_remove(v0, "_\\d+_\\d+$")           # strip MA/OBV window suffixes if present

  macro_set  <- c("ret","Rfree","tbl","corpr","AAA","BAA","dfy","dfr","tms",
                  "lty","ltr","infl","ntis","ndrbl","erp")
  ratios_set <- c("d12","e12","d_p","d_y","e_p","d_e","b_m")
  senti_set  <- c("ygap")                 
  var_set    <- c("impvar","vrp","rsvix","svar")
  xsec_set   <- c("avgcor","skvw","tail","rdsp","lzrt")
  other_set  <- c("dtoy","dtoat","Volume") 
  commod_set <- c("wtexas")

  case_when(
    str_detect(v0, "^(MA_|MOM|OBV)")                               ~ "Other Stock Market",
    v0 %in% ratios_set                                             ~ "Valuation (Ratios)",
    v0 %in% commod_set                                ~ "Commodities",
    v0 %in% var_set                                   ~ "Variance-Related",
    v0 %in% xsec_set                                  ~ "Stock Cross-Section",
    v0 %in% senti_set                                 ~ "Sentiment",
    v0 %in% other_set                                 ~ "Other Stock Market",
    v0 %in% macro_set                                 ~ "Macroeconomic"
  )
}
```

```{r}
# Initialize environment for SHAP accumulation
xgb_shap_ts <- new.env(parent = emptyenv())

# Reset function to clear accumulated SHAP values
xgb_shap_ts_reset <- function() { xgb_shap_ts$mat <- list(); xgb_shap_ts$dates <- list() }

# Function to update SHAP values per horizon
xgb_shap_ts_push  <- function(h, shap_named_vec) {
  key <- as.character(h)
  df  <- as.data.frame(t(shap_named_vec))  # 1xP, names=features
  xgb_shap_ts$mat[[key]] <- dplyr::bind_rows(xgb_shap_ts$mat[[key]], df)
}
xgb_shap_ts_set_dates <- function(h, dates_vec) {
  key <- as.character(h); xgb_shap_ts$dates[[key]] <- as.Date(dates_vec)
}

shap_group_ts <- function(h) {
  key <- as.character(h)
  M <- xgb_shap_ts$mat[[key]]
  if (is.null(M) || nrow(M) == 0) return(data.frame())
  # long format
  M$.__row <- seq_len(nrow(M))
  long <- tidyr::pivot_longer(M, -.__row, names_to = "feature", values_to = "abs_shap")
  long$group <- assign_group_4way(long$feature)

  # attach dates if provided; else index
  if (!is.null(xgb_shap_ts$dates[[key]]) && length(xgb_shap_ts$dates[[key]]) == nrow(M)) {
    long$date <- xgb_shap_ts$dates[[key]][long$.__row]
  } else {
    long$date <- long$.__row
  }

  long %>%
    group_by(date, group) %>%
    summarise(group_abs_shap = sum(abs_shap, na.rm = TRUE), .groups = "drop") %>%
    group_by(date) %>%
    mutate(share = group_abs_shap / sum(group_abs_shap)) %>%
    ungroup()
}

# Reset SHAP accumulation environment at the start
xgb_shap_ts_reset()
```

```{r}
# Define the model function to fit XGBoost, calculate SHAP values, and update the accumulator
model <- function(df, h) {
  
  # Standardize data and create target variable
  df_std = df %>% mutate(across(-c(date, erp), ~ as.numeric(scale(.)))) %>% arrange(date)
  df_std = df_std %>% mutate(target = dplyr::lead(erp, n = h)) %>% select(date, target, everything())

  df_forecast = df_std %>% dplyr::slice(n()-h+1)
  df_train = df_std %>% dplyr::slice(1:(n() - h))

  feats <- setdiff(names(df_std), c("date", "target"))
  
  # Prepare the training data and labels
  x_train <- as.matrix(df_train[, feats, drop = FALSE])
  y_train <- df_train$target
  x_forecast <- as.matrix(df_forecast[, feats, drop = FALSE])
  
  # Create DMatrix for XGBoost
  dtrain <- xgb.DMatrix(data = x_train, label = y_train)
  dforecast <- xgb.DMatrix(data = x_forecast)

  # Train XGBoost model
  set.seed(456857)
  xgb_fit <- xgboost(
    data = dtrain,
    objective = "reg:squarederror",
    eval_metric = "rmse",
    nrounds = 500,
    eta = 0.01,
    max_depth = 2,
    min_child_weight = 1,
    subsample = 0.5,
    colsample_bytree = 0.5,
    gamma = 0,
    verbose = 0
  )

  # Predict for the forecast row
  pred <- predict(xgb_fit, newdata = dforecast)
  

  # SHAP for the forecast row
  sh <- predict(xgb_fit, dforecast, predcontrib = TRUE)
  sh <- as.numeric(sh[1, ])   # includes BIAS term as last column
  names(sh) <- c(feats, "BIAS")
  sh_feat <- abs(sh[names(sh) != "BIAS"])  # use absolute SHAP for aggregation
  
  # accumulate per-h
  xgb_shap_ts_push(h, sh_feat)
  
  return(pred)
}
```

```{r}
# Set window size for the rolling window approach
WINDOW_SIZE = 100
model_name = 'model_name'

run_recursive_window <- function(df, model_name) {
  
  date_col <- tail(df[[1]], WINDOW_SIZE) 
  T_total <- nrow(df)
  
  # Initialize empty dataframe for storing SHAP results
  preds_df <- data.frame(
    date = date_col,              
    count_technical = rep(NA_integer_, WINDOW_SIZE),
    count_other = rep(NA_integer_, WINDOW_SIZE)
  )
  
  # Loop over the rolling window
  for (t in seq(T_total - WINDOW_SIZE + 1, T_total)) { 
    trim_index <- t - 1
    test_index <- t - (T_total - WINDOW_SIZE + 1)
    df_trimmed <- df[0+test_index:trim_index, , drop = FALSE]
    
    # Call the model function for SHAP updates
    counts_list <- model(df_trimmed, h)
    
    # Store SHAP counts
    preds_df$count_technical[test_index + 1] <- counts_list$tech
    preds_df$count_other[test_index + 1] <- counts_list$other
    preds_df$total[test_index + 1] <- counts_list$tech + counts_list$other
  }
  
  return(list(preds_df = preds_df))
}

# Running the model for each horizon
res <- run_recursive_window(df, model_name)
```

```{r}
# Plot SHAP values for each horizon (h = 1, 3, 6, 12)
xgb_shap_ts_set_dates(h, date_col)

gh_ts <- shap_group_ts(h)
ggplot(gh_ts, aes(x = date, y = group_abs_shap, color = group)) +
  geom_line() +
  labs(title = paste0("h=", h, " grouped |SHAP| over time"), x = NULL, y = "sum |SHAP| (per month)") +
  theme_minimal()
```
